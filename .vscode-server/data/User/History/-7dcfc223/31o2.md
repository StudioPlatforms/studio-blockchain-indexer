# Comprehensive Guide to Verifying Complex Multi-file Contracts

This guide provides detailed instructions for developers who want to verify complex multi-file contracts like Uniswap v3 using our enhanced verification system.

## Table of Contents

1. [Overview](#overview)
2. [Prerequisites](#prerequisites)
3. [Step 1: Collecting Source Files](#step-1-collecting-source-files)
4. [Step 2: Organizing Source Files](#step-2-organizing-source-files)
5. [Step 3: Preparing the Verification Request](#step-3-preparing-the-verification-request)
6. [Step 4: Submitting the Verification Request](#step-4-submitting-the-verification-request)
7. [Step 5: Handling Verification Results](#step-5-handling-verification-results)
8. [Troubleshooting](#troubleshooting)
9. [Examples](#examples)
   - [Verifying Uniswap v3 Factory](#verifying-uniswap-v3-factory)
   - [Verifying Uniswap v3 Position Manager](#verifying-uniswap-v3-position-manager)
10. [Best Practices](#best-practices)

## Overview

Our enhanced verification system allows you to verify complex multi-file contracts that were previously difficult or impossible to verify. The system supports:

- Multi-file contracts with complex import structures
- npm-style imports (e.g., `@uniswap/v3-core/contracts/...`)
- Automatic main file detection
- Improved error reporting

## Prerequisites

Before you begin, make sure you have:

1. The contract address you want to verify
2. The exact compiler version used to deploy the contract
3. The contract name
4. Optimization settings (enabled/disabled and runs)
5. Constructor arguments (if any)
6. Library addresses (if any)
7. All source files used in the contract

## Step 1: Collecting Source Files

For complex contracts like Uniswap v3, you'll need to collect all source files from the relevant repositories.

### For Uniswap v3:

1. Clone the repositories:
   ```bash
   git clone https://github.com/Uniswap/v3-core.git
   git clone https://github.com/Uniswap/v3-periphery.git
   ```

2. Checkout the exact commit used for deployment:
   ```bash
   cd v3-core
   git checkout 0.8.0  # or the specific commit/tag used
   cd ../v3-periphery
   git checkout 0.8.0  # or the specific commit/tag used
   ```

3. Identify all the Solidity files (`.sol`) in the repositories:
   ```bash
   find v3-core -name "*.sol" > uniswap-files.txt
   find v3-periphery -name "*.sol" >> uniswap-files.txt
   ```

## Step 2: Organizing Source Files

The key to successful verification is organizing the source files with the correct paths that match the import statements in the code.

1. Create a directory structure that matches the import paths:

   ```
   verification-files/
   ├── @uniswap/
   │   ├── v3-core/
   │   │   └── contracts/
   │   │       ├── interfaces/
   │   │       ├── libraries/
   │   │       └── ...
   │   └── v3-periphery/
   │       └── contracts/
   │           ├── interfaces/
   │           ├── libraries/
   │           └── ...
   └── ...
   ```

2. Copy the source files to the appropriate directories:

   ```bash
   mkdir -p verification-files/@uniswap/v3-core/contracts
   mkdir -p verification-files/@uniswap/v3-periphery/contracts
   
   # Copy core files
   cp -r v3-core/contracts/* verification-files/@uniswap/v3-core/contracts/
   
   # Copy periphery files
   cp -r v3-periphery/contracts/* verification-files/@uniswap/v3-periphery/contracts/
   ```

3. Verify that the directory structure matches the import statements in the code. For example, if a file has:

   ```solidity
   import '@uniswap/v3-core/contracts/interfaces/IUniswapV3Factory.sol';
   ```

   Then you should have a file at:

   ```
   verification-files/@uniswap/v3-core/contracts/interfaces/IUniswapV3Factory.sol
   ```

## Step 3: Preparing the Verification Request

Now you need to prepare a JSON object with all the source files and verification parameters.

1. Create a script to read all the source files and generate a JSON object:

   ```javascript
   const fs = require('fs');
   const path = require('path');

   const baseDir = 'verification-files';
   const sourceFiles = {};

   function readFilesRecursively(dir, baseDir) {
     const files = fs.readdirSync(dir);
     
     files.forEach(file => {
       const filePath = path.join(dir, file);
       const stat = fs.statSync(filePath);
       
       if (stat.isDirectory()) {
         readFilesRecursively(filePath, baseDir);
       } else if (file.endsWith('.sol')) {
         const relativePath = path.relative(baseDir, filePath);
         sourceFiles[relativePath] = fs.readFileSync(filePath, 'utf8');
       }
     });
   }

   readFilesRecursively(baseDir, baseDir);

   // Create the verification request object
   const verificationRequest = {
     address: '0x1F98431c8aD98523631AE4a59f267346ea31F984', // Replace with your contract address
     compilerVersion: '0.7.6',
     contractName: 'UniswapV3Factory', // Replace with your contract name
     optimizationUsed: true,
     runs: 200,
     evmVersion: 'istanbul',
     sourceFiles: sourceFiles
   };

   // Add constructor arguments if needed
   if (process.env.CONSTRUCTOR_ARGS) {
     verificationRequest.constructorArguments = process.env.CONSTRUCTOR_ARGS;
   }

   // Add libraries if needed
   if (process.env.LIBRARIES) {
     verificationRequest.libraries = JSON.parse(process.env.LIBRARIES);
   }

   fs.writeFileSync('verification-request.json', JSON.stringify(verificationRequest, null, 2));
   ```

2. Run the script to generate the verification request:

   ```bash
   node generate-verification-request.js
   ```

## Step 4: Submitting the Verification Request

Submit the verification request to the API endpoint:

```bash
curl -X POST http://localhost:3000/contracts/verify-multi \
  -H "Content-Type: application/json" \
  -d @verification-request.json
```

For large contracts, you might need to increase the timeout:

```bash
curl -X POST http://localhost:3000/contracts/verify-multi \
  -H "Content-Type: application/json" \
  --max-time 300 \
  -d @verification-request.json
```

## Step 5: Handling Verification Results

The API will respond with a JSON object indicating whether the verification was successful:

```json
{
  "success": true,
  "message": "Contract verified successfully",
  "address": "0x1F98431c8aD98523631AE4a59f267346ea31F984",
  "abi": [...],
  "metadata": "...",
  "metadataHash": "0xa165627a7a72305820...",
  "mainFile": "@uniswap/v3-core/contracts/UniswapV3Factory.sol"
}
```

If the verification fails, you'll receive an error message with details about what went wrong:

```json
{
  "success": false,
  "error": "Verification failed: Compilation errors: ..."
}
```

## Troubleshooting

### Common Issues and Solutions

1. **Import not found**

   Error:
   ```
   File not found: @uniswap/v3-core/contracts/interfaces/IUniswapV3Factory.sol
   ```

   Solution:
   - Check that the file exists in your `sourceFiles` object
   - Ensure the path matches exactly with the import statement in the code
   - Try adding the file with different path variations

2. **Compiler version mismatch**

   Error:
   ```
   Failed to load compiler version 0.7.6+commit.7338295f
   ```

   Solution:
   - Use just the major.minor.patch version (e.g., "0.7.6") without the commit hash
   - Ensure the compiler version matches the one used for deployment

3. **Bytecode verification failed**

   Error:
   ```
   Bytecode verification failed. The compiled bytecode does not match the on-chain bytecode.
   ```

   Solution:
   - Double-check the compiler version
   - Ensure optimization settings match those used for deployment
   - Verify that all libraries are correctly linked
   - Check that constructor arguments are correct

4. **Memory issues during compilation**

   Error:
   ```
   JavaScript heap out of memory
   ```

   Solution:
   - Try reducing the number of source files by only including the necessary ones
   - Increase the memory limit for the Node.js process

## Examples

### Verifying Uniswap v3 Factory

Here's a complete example for verifying the Uniswap v3 Factory contract:

```json
{
  "address": "0x1F98431c8aD98523631AE4a59f267346ea31F984",
  "compilerVersion": "0.7.6",
  "contractName": "UniswapV3Factory",
  "optimizationUsed": true,
  "runs": 200,
  "evmVersion": "istanbul",
  "sourceFiles": {
    "@uniswap/v3-core/contracts/UniswapV3Factory.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity =0.7.6;\n\nimport './interfaces/IUniswapV3Factory.sol';\nimport './UniswapV3Pool.sol';\n\n/// @title Canonical Uniswap V3 factory\n/// @notice Deploys Uniswap V3 pools and manages ownership and control over pool protocol fees\ncontract UniswapV3Factory is IUniswapV3Factory {\n    // ... rest of the code ...\n}",
    "@uniswap/v3-core/contracts/interfaces/IUniswapV3Factory.sol": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title The interface for the Uniswap V3 Factory\n/// @notice The Uniswap V3 Factory facilitates creation of Uniswap V3 pools and control over the protocol fees\ninterface IUniswapV3Factory {\n    // ... rest of the code ...\n}",
    // Include all other necessary files
  }
}
```

### Verifying Uniswap v3 Position Manager

Here's a complete example for verifying the Uniswap v3 NonfungiblePositionManager contract:

```json
{
  "address": "0xC36442b4a4522E871399CD717aBDD847Ab11FE88",
  "compilerVersion": "0.7.6",
  "contractName": "NonfungiblePositionManager",
  "optimizationUsed": true,
  "runs": 200,
  "evmVersion": "istanbul",
  "libraries": {
    "NFTDescriptor": "0x42B24A95702b9986e82d421cC3568932790A48Ec"
  },
  "sourceFiles": {
    "@uniswap/v3-periphery/contracts/NonfungiblePositionManager.sol": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity =0.7.6;\npragma abicoder v2;\n\n// ... imports ...\n\n/// @title NFT positions\n/// @notice Wraps Uniswap V3 positions in the ERC721 non-fungible token interface\ncontract NonfungiblePositionManager is\n    INonfungiblePositionManager,\n    Multicall,\n    ERC721Permit,\n    PeripheryImmutableState,\n    PoolInitializer,\n    LiquidityManagement\n{\n    // ... rest of the code ...\n}",
    // Include all other necessary files
  }
}
```

## Best Practices

1. **Organize Source Files Carefully**
   - Match the directory structure to the import statements
   - Keep the original file paths from the repositories

2. **Verify One Contract at a Time**
   - Focus on verifying one contract at a time
   - Start with the main contract and then verify dependencies

3. **Use the Correct Compiler Version**
   - Always use the exact compiler version used for deployment
   - Specify just the major.minor.patch version (e.g., "0.7.6")

4. **Handle Libraries Correctly**
   - Provide the correct addresses for all libraries
   - Use the format `File.sol:Library` for libraries in different files

5. **Optimize the Verification Process**
   - Only include the necessary source files
   - Use the correct EVM version for the compiler version

6. **Debug Verification Failures**
   - Check the error messages for specific issues
   - Try different variations of import paths
   - Verify that all dependencies are included

7. **Document the Verification Process**
   - Keep track of the verification parameters
   - Document any special steps or considerations

By following these guidelines, you should be able to successfully verify even the most complex multi-file contracts like Uniswap v3.
